{"remainingRequest":"C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\ngx-bootstrap\\datepicker\\reducer\\bs-datepicker.reducer.js","dependencies":[{"path":"C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\ngx-bootstrap\\datepicker\\reducer\\bs-datepicker.reducer.js","mtime":1676443216894},{"path":"C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1676443201610},{"path":"C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1676443192566}],"contextDependencies":[],"result":["import { initialDatepickerState } from './bs-datepicker.state';\r\nimport { BsDatepickerActions } from './bs-datepicker.actions';\r\nimport { calcDaysCalendar } from '../engine/calc-days-calendar';\r\nimport { formatDaysCalendar } from '../engine/format-days-calendar';\r\nimport { flagDaysCalendar } from '../engine/flag-days-calendar';\r\nimport { setFullDate, shiftDate } from '../../chronos/utils/date-setters';\r\nimport { canSwitchMode } from '../engine/view-mode';\r\nimport { formatMonthsCalendar } from '../engine/format-months-calendar';\r\nimport { flagMonthsCalendar } from '../engine/flag-months-calendar';\r\nimport { formatYearsCalendar, yearsPerCalendar } from '../engine/format-years-calendar';\r\nimport { flagYearsCalendar } from '../engine/flag-years-calendar';\r\nimport { isArray, isDateValid } from '../../chronos/utils/type-checks';\r\nimport { startOf } from '../../chronos/utils/start-end-of';\r\nimport { getLocale } from '../../chronos/locale/locales';\r\nimport { isAfter, isBefore } from '../../chronos/utils/date-compare';\r\nexport function bsDatepickerReducer(state, action) {\r\n    if (state === void 0) { state = initialDatepickerState; }\r\n    switch (action.type) {\r\n        case BsDatepickerActions.CALCULATE: {\r\n            return calculateReducer(state);\r\n        }\r\n        case BsDatepickerActions.FORMAT: {\r\n            return formatReducer(state, action);\r\n        }\r\n        case BsDatepickerActions.FLAG: {\r\n            return flagReducer(state, action);\r\n        }\r\n        case BsDatepickerActions.NAVIGATE_OFFSET: {\r\n            var date = shiftDate(startOf(state.view.date, 'month'), action.payload);\r\n            var newState = {\r\n                view: {\r\n                    mode: state.view.mode,\r\n                    date: date\r\n                }\r\n            };\r\n            return Object.assign({}, state, newState);\r\n        }\r\n        case BsDatepickerActions.NAVIGATE_TO: {\r\n            var payload = action.payload;\r\n            var date = setFullDate(state.view.date, payload.unit);\r\n            var mode = payload.viewMode;\r\n            var newState = { view: { date: date, mode: mode } };\r\n            return Object.assign({}, state, newState);\r\n        }\r\n        case BsDatepickerActions.CHANGE_VIEWMODE: {\r\n            if (!canSwitchMode(action.payload)) {\r\n                return state;\r\n            }\r\n            var date = state.view.date;\r\n            var mode = action.payload;\r\n            var newState = { view: { date: date, mode: mode } };\r\n            return Object.assign({}, state, newState);\r\n        }\r\n        case BsDatepickerActions.HOVER: {\r\n            return Object.assign({}, state, { hoveredDate: action.payload });\r\n        }\r\n        case BsDatepickerActions.SELECT: {\r\n            var newState = {\r\n                selectedDate: action.payload,\r\n                view: state.view\r\n            };\r\n            var mode = state.view.mode;\r\n            var _date = action.payload || state.view.date;\r\n            var date = getViewDate(_date, state.minDate, state.maxDate);\r\n            newState.view = { mode: mode, date: date };\r\n            return Object.assign({}, state, newState);\r\n        }\r\n        case BsDatepickerActions.SET_OPTIONS: {\r\n            var newState = action.payload;\r\n            // preserve view mode\r\n            var mode = state.view.mode;\r\n            var _viewDate = isDateValid(newState.value) && newState.value\r\n                || isArray(newState.value) && isDateValid(newState.value[0]) && newState.value[0]\r\n                || state.view.date;\r\n            var date = getViewDate(_viewDate, newState.minDate, newState.maxDate);\r\n            newState.view = { mode: mode, date: date };\r\n            // update selected value\r\n            if (newState.value) {\r\n                // if new value is array we work with date range\r\n                if (isArray(newState.value)) {\r\n                    newState.selectedRange = newState.value;\r\n                }\r\n                // if new value is a date -> datepicker\r\n                if (newState.value instanceof Date) {\r\n                    newState.selectedDate = newState.value;\r\n                }\r\n                // provided value is not supported :)\r\n                // need to report it somehow\r\n            }\r\n            return Object.assign({}, state, newState);\r\n        }\r\n        // date range picker\r\n        case BsDatepickerActions.SELECT_RANGE: {\r\n            var newState = {\r\n                selectedRange: action.payload,\r\n                view: state.view\r\n            };\r\n            var mode = state.view.mode;\r\n            var _date = action.payload && action.payload[0] || state.view.date;\r\n            var date = getViewDate(_date, state.minDate, state.maxDate);\r\n            newState.view = { mode: mode, date: date };\r\n            return Object.assign({}, state, newState);\r\n        }\r\n        case BsDatepickerActions.SET_MIN_DATE: {\r\n            return Object.assign({}, state, {\r\n                minDate: action.payload\r\n            });\r\n        }\r\n        case BsDatepickerActions.SET_MAX_DATE: {\r\n            return Object.assign({}, state, {\r\n                maxDate: action.payload\r\n            });\r\n        }\r\n        case BsDatepickerActions.SET_IS_DISABLED: {\r\n            return Object.assign({}, state, {\r\n                isDisabled: action.payload\r\n            });\r\n        }\r\n        default:\r\n            return state;\r\n    }\r\n}\r\nfunction calculateReducer(state) {\r\n    // how many calendars\r\n    var displayMonths = state.displayMonths;\r\n    // use selected date on initial rendering if set\r\n    var viewDate = state.view.date;\r\n    if (state.view.mode === 'day') {\r\n        state.monthViewOptions.firstDayOfWeek = getLocale(state.locale).firstDayOfWeek();\r\n        var monthsModel = new Array(displayMonths);\r\n        for (var monthIndex = 0; monthIndex < displayMonths; monthIndex++) {\r\n            // todo: for unlinked calendars it will be harder\r\n            monthsModel[monthIndex] = calcDaysCalendar(viewDate, state.monthViewOptions);\r\n            viewDate = shiftDate(viewDate, { month: 1 });\r\n        }\r\n        return Object.assign({}, state, { monthsModel: monthsModel });\r\n    }\r\n    if (state.view.mode === 'month') {\r\n        var monthsCalendar = new Array(displayMonths);\r\n        for (var calendarIndex = 0; calendarIndex < displayMonths; calendarIndex++) {\r\n            // todo: for unlinked calendars it will be harder\r\n            monthsCalendar[calendarIndex] = formatMonthsCalendar(viewDate, getFormatOptions(state));\r\n            viewDate = shiftDate(viewDate, { year: 1 });\r\n        }\r\n        return Object.assign({}, state, { monthsCalendar: monthsCalendar });\r\n    }\r\n    if (state.view.mode === 'year') {\r\n        var yearsCalendarModel = new Array(displayMonths);\r\n        for (var calendarIndex = 0; calendarIndex < displayMonths; calendarIndex++) {\r\n            // todo: for unlinked calendars it will be harder\r\n            yearsCalendarModel[calendarIndex] = formatYearsCalendar(viewDate, getFormatOptions(state));\r\n            viewDate = shiftDate(viewDate, { year: yearsPerCalendar });\r\n        }\r\n        return Object.assign({}, state, { yearsCalendarModel: yearsCalendarModel });\r\n    }\r\n    return state;\r\n}\r\nfunction formatReducer(state, action) {\r\n    if (state.view.mode === 'day') {\r\n        var formattedMonths = state.monthsModel.map(function (month, monthIndex) {\r\n            return formatDaysCalendar(month, getFormatOptions(state), monthIndex);\r\n        });\r\n        return Object.assign({}, state, { formattedMonths: formattedMonths });\r\n    }\r\n    // how many calendars\r\n    var displayMonths = state.displayMonths;\r\n    // check initial rendering\r\n    // use selected date on initial rendering if set\r\n    var viewDate = state.view.date;\r\n    if (state.view.mode === 'month') {\r\n        var monthsCalendar = new Array(displayMonths);\r\n        for (var calendarIndex = 0; calendarIndex < displayMonths; calendarIndex++) {\r\n            // todo: for unlinked calendars it will be harder\r\n            monthsCalendar[calendarIndex] = formatMonthsCalendar(viewDate, getFormatOptions(state));\r\n            viewDate = shiftDate(viewDate, { year: 1 });\r\n        }\r\n        return Object.assign({}, state, { monthsCalendar: monthsCalendar });\r\n    }\r\n    if (state.view.mode === 'year') {\r\n        var yearsCalendarModel = new Array(displayMonths);\r\n        for (var calendarIndex = 0; calendarIndex < displayMonths; calendarIndex++) {\r\n            // todo: for unlinked calendars it will be harder\r\n            yearsCalendarModel[calendarIndex] = formatYearsCalendar(viewDate, getFormatOptions(state));\r\n            viewDate = shiftDate(viewDate, { year: 16 });\r\n        }\r\n        return Object.assign({}, state, { yearsCalendarModel: yearsCalendarModel });\r\n    }\r\n    return state;\r\n}\r\nfunction flagReducer(state, action) {\r\n    if (state.view.mode === 'day') {\r\n        var flaggedMonths = state.formattedMonths.map(function (formattedMonth, monthIndex) {\r\n            return flagDaysCalendar(formattedMonth, {\r\n                isDisabled: state.isDisabled,\r\n                minDate: state.minDate,\r\n                maxDate: state.maxDate,\r\n                hoveredDate: state.hoveredDate,\r\n                selectedDate: state.selectedDate,\r\n                selectedRange: state.selectedRange,\r\n                displayMonths: state.displayMonths,\r\n                monthIndex: monthIndex\r\n            });\r\n        });\r\n        return Object.assign({}, state, { flaggedMonths: flaggedMonths });\r\n    }\r\n    if (state.view.mode === 'month') {\r\n        var flaggedMonthsCalendar = state.monthsCalendar.map(function (formattedMonth, monthIndex) {\r\n            return flagMonthsCalendar(formattedMonth, {\r\n                isDisabled: state.isDisabled,\r\n                minDate: state.minDate,\r\n                maxDate: state.maxDate,\r\n                hoveredMonth: state.hoveredMonth,\r\n                displayMonths: state.displayMonths,\r\n                monthIndex: monthIndex\r\n            });\r\n        });\r\n        return Object.assign({}, state, { flaggedMonthsCalendar: flaggedMonthsCalendar });\r\n    }\r\n    if (state.view.mode === 'year') {\r\n        var yearsCalendarFlagged = state.yearsCalendarModel.map(function (formattedMonth, yearIndex) {\r\n            return flagYearsCalendar(formattedMonth, {\r\n                isDisabled: state.isDisabled,\r\n                minDate: state.minDate,\r\n                maxDate: state.maxDate,\r\n                hoveredYear: state.hoveredYear,\r\n                displayMonths: state.displayMonths,\r\n                yearIndex: yearIndex\r\n            });\r\n        });\r\n        return Object.assign({}, state, { yearsCalendarFlagged: yearsCalendarFlagged });\r\n    }\r\n    return state;\r\n}\r\nfunction getFormatOptions(state) {\r\n    return {\r\n        locale: state.locale,\r\n        monthTitle: state.monthTitle,\r\n        yearTitle: state.yearTitle,\r\n        dayLabel: state.dayLabel,\r\n        monthLabel: state.monthLabel,\r\n        yearLabel: state.yearLabel,\r\n        weekNumbers: state.weekNumbers\r\n    };\r\n}\r\n/**\r\n * if view date is provided (bsValue|ngModel) it should be shown\r\n * if view date is not provider:\r\n * if minDate>currentDate (default view value), show minDate\r\n * if maxDate<currentDate(default view value) show maxDate\r\n */\r\nfunction getViewDate(viewDate, minDate, maxDate) {\r\n    var _date = Array.isArray(viewDate) ? viewDate[0] : viewDate;\r\n    if (minDate && isAfter(minDate, _date, 'day')) {\r\n        return minDate;\r\n    }\r\n    if (maxDate && isBefore(maxDate, _date, 'day')) {\r\n        return maxDate;\r\n    }\r\n    return _date;\r\n}\r\n//# sourceMappingURL=bs-datepicker.reducer.js.map",null]}