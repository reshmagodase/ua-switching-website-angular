{"remainingRequest":"C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\ngx-bootstrap\\chronos\\duration\\create.js","dependencies":[{"path":"C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\ngx-bootstrap\\chronos\\duration\\create.js","mtime":1676443216342},{"path":"C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1676443201610},{"path":"C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1676443192566}],"contextDependencies":[],"result":["import { Duration, isDuration } from './constructor';\r\nimport { isDateValid, isNumber, isObject, isString, toInt } from '../utils/type-checks';\r\nimport { DATE, HOUR, MILLISECOND, MINUTE, SECOND } from '../units/constants';\r\nimport { parseDate } from '../create/local';\r\nimport { absRound } from '../utils/abs-round';\r\nimport { cloneWithOffset } from '../units/offset';\r\nimport { isAfter, isBefore } from '../utils/date-compare';\r\nimport { getFullYear, getMonth } from '../utils/date-getters';\r\nimport { add } from '../moment/add-subtract';\r\nimport { cloneDate } from '../create/clone';\r\nvar aspNetRegex = /^(\\-|\\+)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\r\n// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\r\n// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\r\n// and further modified to allow for strings containing both week and day\r\n// tslint:disable-next-line\r\nvar isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\r\nexport function createDuration(input, key, config) {\r\n    if (config === void 0) { config = {}; }\r\n    var duration = convertDuration(input, key);\r\n    // matching against regexp is expensive, do it on demand\r\n    return new Duration(duration, config);\r\n}\r\nfunction convertDuration(input, key) {\r\n    // checks for null or undefined\r\n    if (input == null) {\r\n        return {};\r\n    }\r\n    if (isDuration(input)) {\r\n        return {\r\n            milliseconds: input._milliseconds,\r\n            day: input._days,\r\n            month: input._months\r\n        };\r\n    }\r\n    if (isNumber(input)) {\r\n        // duration = {};\r\n        return key ? (_a = {}, _a[key] = input, _a) : { milliseconds: input };\r\n    }\r\n    if (isString(input)) {\r\n        var match = aspNetRegex.exec(input);\r\n        if (match) {\r\n            var sign = (match[1] === '-') ? -1 : 1;\r\n            return {\r\n                year: 0,\r\n                day: toInt(match[DATE]) * sign,\r\n                hours: toInt(match[HOUR]) * sign,\r\n                minutes: toInt(match[MINUTE]) * sign,\r\n                seconds: toInt(match[SECOND]) * sign,\r\n                // the millisecond decimal point is included in the match\r\n                milliseconds: toInt(absRound(toInt(match[MILLISECOND]) * 1000)) * sign\r\n            };\r\n        }\r\n        match = isoRegex.exec(input);\r\n        if (match) {\r\n            var sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;\r\n            return {\r\n                year: parseIso(match[2], sign),\r\n                month: parseIso(match[3], sign),\r\n                week: parseIso(match[4], sign),\r\n                day: parseIso(match[5], sign),\r\n                hours: parseIso(match[6], sign),\r\n                minutes: parseIso(match[7], sign),\r\n                seconds: parseIso(match[8], sign)\r\n            };\r\n        }\r\n    }\r\n    if (isObject(input) && ('from' in input || 'to' in input)) {\r\n        var diffRes = momentsDifference(parseDate(input.from), parseDate(input.to));\r\n        return {\r\n            milliseconds: diffRes.milliseconds,\r\n            month: diffRes.months\r\n        };\r\n    }\r\n    return input;\r\n    var _a;\r\n}\r\n// createDuration.fn = Duration.prototype;\r\n// createDuration.invalid = invalid;\r\nfunction parseIso(inp, sign) {\r\n    // We'd normally use ~~inp for this, but unfortunately it also\r\n    // converts floats to ints.\r\n    // inp may be undefined, so careful calling replace on it.\r\n    var res = inp && parseFloat(inp.replace(',', '.'));\r\n    // apply sign while we're at it\r\n    return (isNaN(res) ? 0 : res) * sign;\r\n}\r\nfunction positiveMomentsDifference(base, other) {\r\n    var res = { milliseconds: 0, months: 0 };\r\n    res.months = getMonth(other) - getMonth(base) +\r\n        (getFullYear(other) - getFullYear(base)) * 12;\r\n    var _basePlus = add(cloneDate(base), res.months, 'month');\r\n    if (isAfter(_basePlus, other)) {\r\n        --res.months;\r\n    }\r\n    res.milliseconds = +other - +(add(cloneDate(base), res.months, 'month'));\r\n    return res;\r\n}\r\nfunction momentsDifference(base, other) {\r\n    if (!(isDateValid(base) && isDateValid(other))) {\r\n        return { milliseconds: 0, months: 0 };\r\n    }\r\n    var res;\r\n    var _other = cloneWithOffset(other, base, { _offset: base.getTimezoneOffset() });\r\n    if (isBefore(base, _other)) {\r\n        res = positiveMomentsDifference(base, _other);\r\n    }\r\n    else {\r\n        res = positiveMomentsDifference(_other, base);\r\n        res.milliseconds = -res.milliseconds;\r\n        res.months = -res.months;\r\n    }\r\n    return res;\r\n}\r\n//# sourceMappingURL=create.js.map",null]}