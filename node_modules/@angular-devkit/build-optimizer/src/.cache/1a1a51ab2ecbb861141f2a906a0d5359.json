{"remainingRequest":"C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\ngx-bootstrap\\chronos\\create\\from-string-and-format.js","dependencies":[{"path":"C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\ngx-bootstrap\\chronos\\create\\from-string-and-format.js","mtime":1676443216311},{"path":"C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1676443201610},{"path":"C:\\Users\\chinm\\Downloads\\uaswitchingwebsiteangular\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1676443192566}],"contextDependencies":[],"result":["import { configFromISO, configFromRFC2822 } from './from-string';\r\nimport { expandFormat } from '../format';\r\nimport { formattingTokens, formatTokenFunctions } from '../format/format';\r\nimport { isArray } from '../utils/type-checks';\r\nimport { getParseRegexForToken } from '../parse/regex';\r\nimport { addTimeToArrayFromToken } from '../parse/token';\r\nimport { HOUR } from '../units/constants';\r\nimport { configFromArray } from './from-array';\r\nimport { getParsingFlags } from './parsing-flags';\r\nimport { checkOverflow } from './check-overflow';\r\n// constant that refers to the ISO standard\r\n// hooks.ISO_8601 = function () {};\r\nexport var ISO_8601 = 'ISO_8601';\r\n// constant that refers to the RFC 2822 form\r\n// hooks.RFC_2822 = function () {};\r\nexport var RFC_2822 = 'RFC_2822';\r\n// date from string and format string\r\nexport function configFromStringAndFormat(config) {\r\n    // TODO: Move this to another part of the creation flow to prevent circular deps\r\n    if (config._f === ISO_8601) {\r\n        return configFromISO(config);\r\n    }\r\n    if (config._f === RFC_2822) {\r\n        return configFromRFC2822(config);\r\n    }\r\n    config._a = [];\r\n    getParsingFlags(config).empty = true;\r\n    if (isArray(config._f) || (!config._i && config._i !== 0)) {\r\n        return config;\r\n    }\r\n    // This array is used to make a Date, either with `new Date` or `Date.UTC`\r\n    var input = config._i.toString();\r\n    var totalParsedInputLength = 0;\r\n    var inputLength = input.length;\r\n    var tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\r\n    var i;\r\n    var token;\r\n    var parsedInput;\r\n    var skipped;\r\n    for (i = 0; i < tokens.length; i++) {\r\n        token = tokens[i];\r\n        parsedInput = (input.match(getParseRegexForToken(token, config._locale)) || [])[0];\r\n        if (parsedInput) {\r\n            skipped = input.substr(0, input.indexOf(parsedInput));\r\n            if (skipped.length > 0) {\r\n                getParsingFlags(config).unusedInput.push(skipped);\r\n            }\r\n            input = input.slice(input.indexOf(parsedInput) + parsedInput.length);\r\n            totalParsedInputLength += parsedInput.length;\r\n        }\r\n        // don't parse if it's not a known token\r\n        if (formatTokenFunctions[token]) {\r\n            if (parsedInput) {\r\n                getParsingFlags(config).empty = false;\r\n            }\r\n            else {\r\n                getParsingFlags(config).unusedTokens.push(token);\r\n            }\r\n            addTimeToArrayFromToken(token, parsedInput, config);\r\n        }\r\n        else if (config._strict && !parsedInput) {\r\n            getParsingFlags(config).unusedTokens.push(token);\r\n        }\r\n    }\r\n    // add remaining unparsed input length to the string\r\n    getParsingFlags(config).charsLeftOver = inputLength - totalParsedInputLength;\r\n    if (input.length > 0) {\r\n        getParsingFlags(config).unusedInput.push(input);\r\n    }\r\n    // clear _12h flag if hour is <= 12\r\n    if (config._a[HOUR] <= 12 &&\r\n        getParsingFlags(config).bigHour === true &&\r\n        config._a[HOUR] > 0) {\r\n        getParsingFlags(config).bigHour = void 0;\r\n    }\r\n    getParsingFlags(config).parsedDateParts = config._a.slice(0);\r\n    getParsingFlags(config).meridiem = config._meridiem;\r\n    // handle meridiem\r\n    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\r\n    configFromArray(config);\r\n    return checkOverflow(config);\r\n}\r\nfunction meridiemFixWrap(locale, _hour, meridiem) {\r\n    var hour = _hour;\r\n    if (meridiem == null) {\r\n        // nothing to do\r\n        return hour;\r\n    }\r\n    if (locale.meridiemHour != null) {\r\n        return locale.meridiemHour(hour, meridiem);\r\n    }\r\n    if (locale.isPM == null) {\r\n        // this is not supposed to happen\r\n        return hour;\r\n    }\r\n    // Fallback\r\n    var isPm = locale.isPM(meridiem);\r\n    if (isPm && hour < 12) {\r\n        hour += 12;\r\n    }\r\n    if (!isPm && hour === 12) {\r\n        hour = 0;\r\n    }\r\n    return hour;\r\n}\r\n//# sourceMappingURL=from-string-and-format.js.map",null]}