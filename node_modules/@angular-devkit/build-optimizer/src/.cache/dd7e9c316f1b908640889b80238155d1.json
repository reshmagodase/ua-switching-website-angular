{"remainingRequest":"/home/anaghajoshi/Desktop/Anagha/uaswitchingwebsiteangular/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/anaghajoshi/Desktop/Anagha/uaswitchingwebsiteangular/node_modules/ngx-bootstrap/chronos/create/from-string-and-format.js","dependencies":[{"path":"/home/anaghajoshi/Desktop/Anagha/uaswitchingwebsiteangular/node_modules/ngx-bootstrap/chronos/create/from-string-and-format.js","mtime":1551251660055},{"path":"/home/anaghajoshi/Desktop/Anagha/uaswitchingwebsiteangular/node_modules/cache-loader/dist/cjs.js","mtime":1551251659635},{"path":"/home/anaghajoshi/Desktop/Anagha/uaswitchingwebsiteangular/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1551251659207}],"contextDependencies":[],"result":["import { configFromISO, configFromRFC2822 } from './from-string';\nimport { expandFormat } from '../format';\nimport { formattingTokens, formatTokenFunctions } from '../format/format';\nimport { isArray } from '../utils/type-checks';\nimport { getParseRegexForToken } from '../parse/regex';\nimport { addTimeToArrayFromToken } from '../parse/token';\nimport { HOUR } from '../units/constants';\nimport { configFromArray } from './from-array';\nimport { getParsingFlags } from './parsing-flags';\nimport { checkOverflow } from './check-overflow';\n// constant that refers to the ISO standard\n// hooks.ISO_8601 = function () {};\nexport var ISO_8601 = 'ISO_8601';\n// constant that refers to the RFC 2822 form\n// hooks.RFC_2822 = function () {};\nexport var RFC_2822 = 'RFC_2822';\n// date from string and format string\nexport function configFromStringAndFormat(config) {\n    // TODO: Move this to another part of the creation flow to prevent circular deps\n    if (config._f === ISO_8601) {\n        return configFromISO(config);\n    }\n    if (config._f === RFC_2822) {\n        return configFromRFC2822(config);\n    }\n    config._a = [];\n    getParsingFlags(config).empty = true;\n    if (isArray(config._f) || (!config._i && config._i !== 0)) {\n        return config;\n    }\n    // This array is used to make a Date, either with `new Date` or `Date.UTC`\n    var input = config._i.toString();\n    var totalParsedInputLength = 0;\n    var inputLength = input.length;\n    var tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n    var i;\n    var token;\n    var parsedInput;\n    var skipped;\n    for (i = 0; i < tokens.length; i++) {\n        token = tokens[i];\n        parsedInput = (input.match(getParseRegexForToken(token, config._locale)) || [])[0];\n        if (parsedInput) {\n            skipped = input.substr(0, input.indexOf(parsedInput));\n            if (skipped.length > 0) {\n                getParsingFlags(config).unusedInput.push(skipped);\n            }\n            input = input.slice(input.indexOf(parsedInput) + parsedInput.length);\n            totalParsedInputLength += parsedInput.length;\n        }\n        // don't parse if it's not a known token\n        if (formatTokenFunctions[token]) {\n            if (parsedInput) {\n                getParsingFlags(config).empty = false;\n            }\n            else {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n            addTimeToArrayFromToken(token, parsedInput, config);\n        }\n        else if (config._strict && !parsedInput) {\n            getParsingFlags(config).unusedTokens.push(token);\n        }\n    }\n    // add remaining unparsed input length to the string\n    getParsingFlags(config).charsLeftOver = inputLength - totalParsedInputLength;\n    if (input.length > 0) {\n        getParsingFlags(config).unusedInput.push(input);\n    }\n    // clear _12h flag if hour is <= 12\n    if (config._a[HOUR] <= 12 &&\n        getParsingFlags(config).bigHour === true &&\n        config._a[HOUR] > 0) {\n        getParsingFlags(config).bigHour = void 0;\n    }\n    getParsingFlags(config).parsedDateParts = config._a.slice(0);\n    getParsingFlags(config).meridiem = config._meridiem;\n    // handle meridiem\n    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n    configFromArray(config);\n    return checkOverflow(config);\n}\nfunction meridiemFixWrap(locale, _hour, meridiem) {\n    var hour = _hour;\n    if (meridiem == null) {\n        // nothing to do\n        return hour;\n    }\n    if (locale.meridiemHour != null) {\n        return locale.meridiemHour(hour, meridiem);\n    }\n    if (locale.isPM == null) {\n        // this is not supposed to happen\n        return hour;\n    }\n    // Fallback\n    var isPm = locale.isPM(meridiem);\n    if (isPm && hour < 12) {\n        hour += 12;\n    }\n    if (!isPm && hour === 12) {\n        hour = 0;\n    }\n    return hour;\n}\n//# sourceMappingURL=from-string-and-format.js.map",null]}